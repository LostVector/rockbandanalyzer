package com.rkuo.RockBand.ExeHelper;

import com.rkuo.RockBand.Primitives.DrumChart;
import com.rkuo.RockBand.Primitives.DrumsFullAnalysis;
import com.rkuo.RockBand.Simulators.DrumsSimulator;
import com.rkuo.RockBand.Simulators.DrumsSimulatorParameters;
import com.rkuo.RockBand.*;
import com.rkuo.Midi.*;
//import javax.sound.midi.*;

//import javax.sound.midi.Sequence;
//import javax.sound.midi.MidiSystem;
//import javax.sound.midi.InvalidMidiDataException;
import java.io.*;
import java.util.ArrayList;

/**
 * Created by IntelliJ IDEA.
 * User: rkuo
 * Date: Apr 19, 2009
 * Time: 8:34:44 PM
 * To change this template use File | Settings | File Templates.
 */
public class RockBandAnalyzer {

    public static DrumsFullAnalysis AnalyzeStream( PrintWriter psOut, InputStream inStream, RockBandAnalyzerParams rbap ) {

        Sequence s;
        DrumChart dc;

        if( psOut == null ) {
            psOut = new PrintWriter( new StringWriter() );
        }
        
        RockBandPrint.PrintAnalyzerParameters( psOut, rbap );

        try {
            s = MidiSystem.getSequence( inStream );
//            s = MidiSystem.getSequence( inStream );
        }
//        catch( InvalidMidiDataException imde ) {
//            psOut.format( "InvalidMidiDataException\n" );
//            psOut.format( "The stream may not be a valid MIDI file.\n" );
//            s = null;
//        }
        catch( Exception e ) {
            psOut.format( "Exception\n" );
            s = null;
        }

        if( s == null ) {
            psOut.format( "The stream could not be opened.\n");
            return null;
        }

//        RockBandMidi.DumpSequence( s );
//        RockBandMidi.DumpTempoTrack( s );

        psOut.format( "Opened the stream successfully.\n" );

        dc = Convert.ToDrumChart( RockBandChartDifficulty.Expert, s );
//        dc = null;
        if( dc == null ) {
            psOut.format( "Convert.ToDrumChart returned null.\n");
            return null;
        }

        // Print stats
        if( rbap.PrintChart == true ) {
            RockBandPrint.PrintDrumChart( psOut, dc );
        }

        DrumsSimulator dg;
        DrumsSimulatorParameters dsp;
        DrumsFullAnalysis   dfa;
        ArrayList<RockBandPath> paths;

        dfa = new DrumsFullAnalysis();
        dg = new DrumsSimulator();
        dsp = new DrumsSimulatorParameters();
        dsp.FillDelay = RockBandConstants.FillDelayRB2Expert;

        RockBandPrint.PrintDrumsSimulatorParameters( psOut, dsp );

        dfa.dba = dg.GenerateBaselineData( dc );
        if( dfa.dba == null ) {
            return null;
        }
        
        RockBandPrint.PrintDrumsBaselineData( psOut, dfa.dba );

        Integer[]   zeroPath;

        zeroPath = new Integer[1];
        zeroPath[0] = 0;

        paths = dg.GenerateScoreFromPath( dsp, dc, zeroPath );
        psOut.format( "===== Immediate activation path =====\n" );
        RockBandPrint.PrintPaths( psOut, paths );

        dfa.RB2PathImmediate = paths.get(0);

        if( rbap.PathingAlgorithm == RockBandPathingAlgorithm.Predefined ) {
            paths = dg.GenerateScoreFromPath( dsp, dc, rbap.Path.toArray( new Integer[rbap.Path.size()]) );
            RockBandPrint.PrintPaths( psOut, paths );
        }
        else if( rbap.PathingAlgorithm == RockBandPathingAlgorithm.Optimal ) {
            paths = dg.GenerateOptimalPaths( dsp, dc );
            dfa.RB2PathNormalOptimal = paths.get( paths.size() - 1 );
            psOut.format( "===== Terminal paths generated by optimal search algorithm for RB2 Normal speed =====\n" );

            dsp.FillDelay = RockBandConstants.FillDelayRB2Expert * RockBandConstants.RB2BreakneckSpeedNumerator / RockBandConstants.RB2BreakneckSpeedDenominator;
            paths = dg.GenerateOptimalPaths( dsp, dc );
            dfa.RB2PathBreakneckOptimal = paths.get( paths.size() - 1 );
            psOut.format( "===== Terminal paths generated by optimal search algorithm for RB2 Normal speed =====\n" );
        }
        else {
            paths = dg.GenerateAllPaths( dsp, dc );
            RockBandPrint.PrintPaths( psOut, paths );
        }

        dfa.RB2PathOverallOptimal = dfa.RB2PathNormalOptimal;
        if( dfa.RB2PathBreakneckOptimal.Score > dfa.RB2PathNormalOptimal.Score ) {
            dfa.RB2PathOverallOptimal = dfa.RB2PathBreakneckOptimal;
        }
        
        return dfa;
    }

}
